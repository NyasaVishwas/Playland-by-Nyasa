<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fruit Ninja Mini 🍉</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #000000, #001a00);
      overflow: hidden;
      font-family: sans-serif;
      color: white;
    }

    #scoreboard, #lives {
      position: fixed;
      top: 15px;
      font-size: 1.4em;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
    }

    #scoreboard { left: 20px; }
    #lives { right: 20px; }

    canvas { display: block; }

    #rules-screen, #game-over-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 20;
      display: none;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1.1em;
      border: none;
      border-radius: 8px;
      background: #ff5e57;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background: #ff7b74;
    }
  </style>
</head>
<body>

<div id="scoreboard">Score: 0</div>
<div id="lives">Lives: ❤️❤️❤️</div>
<canvas id="gameCanvas"></canvas>

<div id="rules-screen">
  <h2>Fruit Ninja Mini 🍉</h2>
  <p>🍎 Swipe fruits using your mouse<br>
     💔 Don't miss them! You only have 3 lives<br>
     💣 Avoid bombs or the game ends instantly!<br>
     🎯 Score as high as you can</p>
  <button onclick="startGame()">Start Game</button>
</div>

<div id="game-over-screen">
  <h2>Game Over</h2>
  <p id="final-score">Your Score: 0</p>
  <button onclick="startGame()">Play Again</button>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  let fruits = [];
  let particles = [];
  let score = 0;
  let lives = 3;
  let gameRunning = false;
  let fruitInterval;
  let prevMouse = { x: 0, y: 0 };

  const emojis = ["🍎", "🍌", "🍉", "🍇", "🍊", "🥝"];
  const bombEmoji = "💣";

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  function createFruit() {
    if (!gameRunning) return;
    const size = 40;

    // 15% chance to spawn a bomb
    const isBomb = Math.random() < 0.15;

    fruits.push({
      x: Math.random() * (canvas.width - size),
      y: -size,
      size,
      speed: 2 + Math.random() * 2,
      emoji: isBomb ? bombEmoji : emojis[Math.floor(Math.random() * emojis.length)],
      sliced: false,
      isBomb: isBomb
    });
  }

  function drawFruit(fruit) {
    ctx.font = `${fruit.size}px serif`;
    ctx.fillText(fruit.emoji, fruit.x, fruit.y);
  }

  function createBurst(x, y, emoji) {
    for (let i = 0; i < 6; i++) {
      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1.0,
        emoji
      });
    }
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.font = `20px serif`;
      ctx.globalAlpha = p.life;
      ctx.fillText(p.emoji, p.x, p.y);
      ctx.globalAlpha = 1.0;
    });
  }

  function updateParticles() {
    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.02;
    });
    particles = particles.filter(p => p.life > 0);
  }

  canvas.addEventListener("mousemove", e => {
    if (!gameRunning) return;
    const currMouse = { x: e.clientX, y: e.clientY };

    fruits.forEach(fruit => {
      if (!fruit.sliced &&
        Math.hypot(fruit.x - currMouse.x, fruit.y - currMouse.y) < 40 &&
        Math.hypot(fruit.x - prevMouse.x, fruit.y - prevMouse.y) < 80) {
        
        fruit.sliced = true;

        // Check if it's a bomb
        if (fruit.isBomb) {
          fruit.emoji = "💥";
          createBurst(fruit.x, fruit.y, "💥");
          updateScore();
          gameOver(true); // Bomb triggered
          return;
        }

        score += 1;
        updateScore();
        createBurst(fruit.x, fruit.y, fruit.emoji);
      }
    });

    prevMouse = currMouse;
  });

  function updateScore() {
    document.getElementById("scoreboard").textContent = `Score: ${score}`;
  }

  function updateLives() {
    document.getElementById("lives").textContent = `Lives: ${"❤️".repeat(lives)}${"🤍".repeat(3 - lives)}`;
  }

  function gameLoop() {
    if (!gameRunning) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    fruits.forEach(fruit => {
      fruit.y += fruit.speed;
      if (!fruit.sliced) drawFruit(fruit);

      if (fruit.y > canvas.height && !fruit.sliced && !fruit.isBomb) {
        fruit.sliced = true;
        lives--;
        updateLives();
        if (lives <= 0) {
          gameOver(false);
        }
      }
    });

    fruits = fruits.filter(f => f.y < canvas.height && !f.sliced);

    updateParticles();
    drawParticles();

    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    score = 0;
    lives = 3;
    fruits = [];
    particles = [];
    gameRunning = true;
    updateScore();
    updateLives();

    document.getElementById("rules-screen").style.display = "none";
    document.getElementById("game-over-screen").style.display = "none";

    clearInterval(fruitInterval);
    fruitInterval = setInterval(createFruit, 800);

    gameLoop();
  }

  function gameOver(triggeredByBomb = false) {
    gameRunning = false;
    clearInterval(fruitInterval);

    const message = triggeredByBomb ? "💥 You hit a bomb!" : `Your Score: ${score}`;
    document.getElementById("final-score").textContent = message;
    document.getElementById("game-over-screen").style.display = "block";
  }

  window.onload = () => {
    document.getElementById("rules-screen").style.display = "block";
  };
</script>

</body>
</html>
